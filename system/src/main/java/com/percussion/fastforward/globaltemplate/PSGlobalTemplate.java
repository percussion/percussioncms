/*
 *     Percussion CMS
 *     Copyright (C) 1999-2020 Percussion Software, Inc.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Affero General Public License for more details.
 *
 *     Mailing Address:
 *
 *      Percussion Software, Inc.
 *      PO Box 767
 *      Burlington, MA 01803, USA
 *      +01-781-438-9900
 *      support@percussion.com
 *      https://www.percussion.com
 *
 *     You should have received a copy of the GNU Affero General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>
 */

package com.percussion.fastforward.globaltemplate;

import com.percussion.xml.PSNodePrinter;
import com.percussion.xml.PSXmlDocumentBuilder;
import com.percussion.xml.PSXmlTreeWalker;
import org.apache.logging.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;
import org.xml.sax.SAXException;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.nio.charset.StandardCharsets;

import static org.apache.commons.lang.StringUtils.isEmpty;

/**
 * This class is the Java representation of the "Global" or "Outer" template
 * introduced in Rhythmyx Simple (code name "Zho" or Fast Forward). A global
 * template is created off of a marked up HTML source. The markups indicate the
 * location of the navigation slots and the body of the page. The body comes
 * from the local template which is a variant for the actual item. The global
 * template, by definition is common for several pages on one or more sites.
 * This provides place for various navigation bars for the page and encloses the
 * actual content specific to the page which we call body of the page.
 * <p>
 * Mere construction of this object does all the steps in creating the outer
 * template XSL which will be ready to be saved on to the server. The steps are
 * summarized below:
 * <p>
 * <ol>
 * <li>Read the markedup source HTML file specified by its name from the
 * provided directory</li>
 * <li>Run Tidy to make it a well formed XML document</li>
 * <li>Modify the HTML &lt;head&gt; element to achieve the following:
 * <ol>
 * <li>Modify the &gt;title&gt;element to make the title dynamic</li>
 * <li>Add an XSL block to insert a global_head template</li>
 * <li>Modify all &lt;link&gt; tags that point to CSS files to point to dynamic
 * location via context variable</li>
 * <li>Modify all &lt;script&gt; tags that point to JavaScript files to point
 * to dynamic location via context variable</li>
 * </ol>
 * </li>
 * <li>Modify all &lt;img&gt; element to change the attribute "src" to point to
 * dynamic location via the context variable for images</li>
 * <li>Insert the XSL blocks navigation slots with appropriate syntax based on
 * the markups in the HTML source</li>
 * <li>Insert the page body spacer which calls the local template to render the
 * body part of the page</li>
 * <li>Run XSpLit to split this prepared HTML document to generate the XSL
 * file, and</li>
 * <li>Post process the XSL document to perform renamng the template names
 * appropriately and remove any &lt;xsl:import&gt;s added by XSpLit</li>
 * </ol>
 * <p>
 * Please refer to the global template documentation for more details of the
 * above steps.
 * <p>
 * The file name for the XSL document which is the final outcome of this class
 * is auto generated by replacing ".htm*" with ".xsl". The saved file always
 * goes a predefined location which is
 * {@link com.percussion.fastforward.globaltemplate.PSRxGlobals#RX_GLOBALS_PATH}.
 * <p>
 * Please note that all parsing and saving of the input and output content uses
 * the UTF-8
 * encoding}
 */
public class PSGlobalTemplate extends PSLoggable
{
   /**
    * Constructor. All the steps described in the class description are
    * performed here.
    * 
    * @param rxRootDir The Rhythmyx root directory, may not be 
    *    <code>null</code> or empty.
    * @param appDir the location of the markedup HTML source file relative to
    *           Rhythmyx root. Must not be <code>null</code> or empty.
    * @param srcHtmlFile name of the marked up HTML source file for the global
    *           template. Must not be <code>null</code> or empty.
    * @param logger {@link org.apache.logging.log4j.Logger logger} to log the
    *           inoformation, warnings or errors. May be <code>null</code> in
    *           which case a logger with default named category will be ceated.
    * @throws IOException in case of any error accessing and reading the source
    *            file.
    * @throws SAXException in case of any error parsing tidied document.
    * @throws SplitterException in case of any error during the splitting the
    *            prepared HTML document to generate the outer template XSL.
    *  
    */
   public PSGlobalTemplate(String rxRootDir, String appDir, String srcHtmlFile, 
      Logger logger) throws IOException, SAXException
   {
      super(logger);

      if (isEmpty(rxRootDir))
      {
         String msg = "rxRootDir must not be null or empty";
         logError(msg);
         throw new IllegalArgumentException(msg);
      }

      if (isEmpty(appDir))
      {
         String msg = "appDir must not be null or empty";
         logError(msg);
         throw new IllegalArgumentException(msg);
      }

      if (isEmpty(srcHtmlFile))
      {
         String msg = "srcHtmlFile must not be null or empty";
         logError(msg);
         throw new IllegalArgumentException(msg);
      }

      m_appDir = rxRootDir + File.separator + appDir;
      File file = new File(m_appDir + File.separator + srcHtmlFile);
      m_name = file.getName();
      int loc = m_name.indexOf('.');
      if (loc != -1)
         m_name = m_name.substring(0, loc);


      try( FileInputStream is = new FileInputStream(file))
      {

         m_xslDoc = PSXmlDocumentBuilder.createXmlDocument(is,true);

      }
   }


   /**
    * Fix the HTML document to make sure that there are no empty &lt;script&gt;
    * elements. HTML document with empty script elements does not render in 
    * IE for example. Adds ";" as the value of such elements.
    */
   private void fixEmptyElements()
   {
      logInfo("Cleaning empty <script> elements to make sure they are not really empty...");

      NodeList nlTemp = m_tidiedHtmlDoc.getElementsByTagName("script");
      for (int i = 0; i < nlTemp.getLength(); i++)
      {
         Element scriptElem = (Element) nlTemp.item(i);
         if (scriptElem.getChildNodes().getLength() < 1)
         {
            Text dummy = m_tidiedHtmlDoc.createTextNode(";");
            scriptElem.appendChild(dummy);
         }
      }
      logInfo("End cleaning empty <script> elements to make sure they are not really empty...");
   }

   /**
    * Modify the XSL document for the following:
    * <p>
    * <ol>
    * <li>Remove &lt;xsl:import&gt;s added by the XSpLit. Global template 
    * does not need these</li>
    * <li>Rename the name "xsplit_body" of the "xsl:call-template" to the 
    * name of the template (m_name) appended with "_body". </li>
    * <li>Rename the name "placeholder_xsplit_body" of the 
    * "xsl:call-template" to "xsplit_body"</li>
    * <li>Rename the root template name to m_name + "_root" and the template 
    * with name "xsplit_body" to m_name + "_body"</li>
    * </ol>
    */
   private void postProcess()
   {
      logInfo("Post processing the global template XSL...");

      logInfo("Removing all <xsl:import>s...");
      //Remove all <xsl:import> tags from the XSL
      NodeList includeElems = m_xslDoc.getElementsByTagName("xsl:import");
      for (int i = includeElems.getLength() - 1; i >= 0; i--)
      {
         Node node = includeElems.item(i);
         node.getParentNode().removeChild(node);
      }

      //Rename the name "xsplit_body" of the "xsl:call-template" to the name 
      //of the template (m_name) appended with "_body". 
      logInfo(
         "Renaming call to template named \"xsplit_body\" to "
            + getName()
            + "_body");

      NodeList callTemplateElems =
         m_xslDoc.getElementsByTagName("xsl:call-template");
      for (int i = 0; i < callTemplateElems.getLength(); i++)
      {
         Element elem = (Element) callTemplateElems.item(i);
         String name = elem.getAttribute("name");
         if (name.equals("xsplit_body"))
         {
            elem.setAttribute("name", getName() + "_body");
         }

      }

      //Rename the name "placeholder_xsplit_body" of the "xsl:call-template" 
      //to "xsplit_body". 
      logInfo(
         "Renaming call to template named \"placeholder_xsplit_body\""
            + "to \"xsplit_body\"");

      for (int i = 0; i < callTemplateElems.getLength(); i++)
      {
         Element elem = (Element) callTemplateElems.item(i);
         String name = elem.getAttribute("name");
         if (name.equals("placeholder_xsplit_body"))
         {
            elem.setAttribute("name", "xsplit_body");
         }

      }

      //Rename the root template name to m_name + "_root" and the template 
      //with name "xsplit_body" to m_name + "_body" 
      logInfo("Renaming root template name to " + getName() + "_body");

      NodeList templateElems = m_xslDoc.getElementsByTagName("xsl:template");
      for (int i = 0; i < templateElems.getLength(); i++)
      {
         Element elem = (Element) templateElems.item(i);
         String name = elem.getAttribute("name");
         if (name.equals("xsplit_root"))
         {
            elem.setAttribute("name", getName() + GLOBAL_TEMPLATE_NAME_SUFFIX);
         }
         else if (name.equals("xsplit_body"))
         {
            elem.setAttribute("name", getName() + "_body");
         }
      }
   }


   /**
    * Parse element recursively for all navigation slots and body place 
    * holder and then insert appropriate slot blocks recognizable by XSpLit.
    * @param elem the element to look for the slot or body markup and 
    * process, must not be <code>null</code>
    */
   private void processChildren(Element elem)
   {
      NodeList children = elem.getChildNodes();
      for (int i = 0; i < children.getLength(); i++)
      {
         Node node = children.item(i);
         if (node.getNodeType() != Node.ELEMENT_NODE)
            continue;

         Element temp = (Element) node;
         String slotName = temp.getAttribute(ATTR_PSXSLOTNAME);
         String isBody = temp.getAttribute(ATTR_PSXBODY);
         if (!"".equals(slotName))
         {
            processSlotTag(temp);
         }
         else if (!"".equals(isBody) && !isBody.equalsIgnoreCase("no"))
         {
            processBodyTag(temp);
         }
         else
         {
            processChildren(temp);
         }
      }
   }

   /**
    * Processes the marked up element for body container to insert an XSL 
    * block that ultimately renders the body part of the page. The markup 
    * attribute will be removed after the XSL block is inserted.
    * @param bodyElem the element that is market up as the place holder for the 
    * body. Assumes that this elemen has the required markup attribute 
    * {@link #ATTR_PSXBODY}.
    */
   private void processBodyTag(Element bodyElem)
   {
      if (bodyElem == null)
         throw new IllegalArgumentException("bodyElem must not be null");

      String bodymarkup = bodyElem.getAttribute(ATTR_PSXBODY);
      if (isEmpty(bodymarkup))
      {  //FB: RV_EXCEPTION_NOT_THROWN NC 1-17-16
         throw new IllegalArgumentException(
               "Element body must have " + ATTR_PSXBODY + " attribute");
      }

      logInfo(
         "Processing element "
            + bodyElem.getTagName()
            + " for local template/body...");

      Node startLocalTemplateComment = m_tidiedHtmlDoc
            .createComment(" start Local Template ");
      Node beginXSLComment = m_tidiedHtmlDoc.createComment(" begin XSL ");

      Element xslForEach = m_tidiedHtmlDoc.createElement("xsl:for-each");
      xslForEach.setAttribute("select", "/");

      Element xslCallTemplate = m_tidiedHtmlDoc
            .createElement("xsl:call-template");
      xslCallTemplate.setAttribute("name", "placeholder_xsplit_body");

      xslForEach.appendChild(xslCallTemplate);

      Node endXSLComment = m_tidiedHtmlDoc.createComment(" end XSL ");
      Node endLocalTemplateComment =
         m_tidiedHtmlDoc.createComment(" end Local Template ");

      NodeList children = bodyElem.getChildNodes();
      for (int i = children.getLength() - 1; i >= 0; i--)
         bodyElem.removeChild(children.item(i));

      bodyElem.appendChild(startLocalTemplateComment);
      bodyElem.appendChild(beginXSLComment);
      bodyElem.appendChild(xslForEach);
      bodyElem.appendChild(endXSLComment);
      bodyElem.appendChild(endLocalTemplateComment);
      bodyElem.removeAttribute(ATTR_PSXBODY);
      logInfo(
         "End processing element "
            + bodyElem.getTagName()
            + " for local template/body...");

   }

   /**
    * Processes the element marked up for a navigation via the attribute 
    * {@link #ATTR_PSXSLOTNAME} slot in that it inserts the slot makup 
    * consumable by the XSpLit. Assumes that this elemen has the required 
    * markup attribute {@link #ATTR_PSXSLOTNAME}. Removes the attribute after 
    * slot XSL markup.
    * @param slotElem element with slot markup, must not be <code>null</code> 
    * and must have the attribute {@link #ATTR_PSXSLOTNAME}.
    */
   private void processSlotTag(Element slotElem)
   {
      if (slotElem == null)
         throw new IllegalArgumentException("slotElem must not be null");

      String slotName = slotElem.getAttribute(ATTR_PSXSLOTNAME);

      if (isEmpty(slotName))
         throw new IllegalArgumentException(
            "slotElem must have " + ATTR_PSXSLOTNAME + " attribute");

      logInfo(
         "Processing element "
            + slotElem.getTagName()
            + " for slots and local template...");

      Node startSlotComment =
         m_tidiedHtmlDoc.createComment(" start slot " + slotName + " ");
      Node startSnippetWrapperComment =
         m_tidiedHtmlDoc.createComment(" start snippet wrapper ");

      Element xslSpanElem = m_tidiedHtmlDoc.createElement("span");
      xslSpanElem.setAttribute("slotname", slotName);
      
      //Transfer pexeditslot attribute from slotmarkup element to span element
      String psxeditslot = slotElem.getAttribute(ATTR_PSXEDITSLOT);
      if(psxeditslot.length()>0)
      {
         xslSpanElem.setAttribute(ATTR_PSXEDITSLOT, psxeditslot);
         slotElem.removeAttribute(ATTR_PSXEDITSLOT);
      }

      Node endSnippetWrapperComment =
         m_tidiedHtmlDoc.createComment(" end snippet wrapper ");
      Node endSlotComment = m_tidiedHtmlDoc.createComment(" end slot ");

      NodeList children = slotElem.getChildNodes();
      for (int i = children.getLength() - 1; i >= 0; i--)
         slotElem.removeChild(children.item(i));

      slotElem.appendChild(startSlotComment);
      slotElem.appendChild(startSnippetWrapperComment);
      slotElem.appendChild(xslSpanElem);
      slotElem.appendChild(endSnippetWrapperComment);
      slotElem.appendChild(endSlotComment);

      slotElem.removeAttribute(ATTR_PSXSLOTNAME);

      logInfo(
         "End processing element "
            + slotElem.getTagName()
            + " for slots and local template...");
   }

   /**
    * Modify all image (&lt;img&gt;) tags and input tags of type image 
    * (&lt;input type='image' ... &lt;/input&gt;) and any other tag that has the 
    * attribute 'background' to add the dynamic locations for the "src" or 
    * "background" attribute in the tidied HTML document. Those tags that 
    * already have dynamic location specified will be ignored. The markup 
    * follows the XSpLit conventions.
    */
   private void modifyImgSrcs()
   {
      logInfo("Processing tags that may have dynamic references to image resources");

      NodeList nlImages = m_tidiedHtmlDoc.getElementsByTagName("*");
      for (int i = 0; i < nlImages.getLength(); i++)
      {
         Element elem = (Element) nlImages.item(i);
         if(elem.getTagName().equals("img"))
         {
            processImgElement(elem, "src");
         }
         else if(elem.getTagName().equals("input"))
         {
            String type = elem.getAttribute("type");
            if(type.equals("image"))
            {
               processImgElement(elem, "src");
            }
         }
         else
         {
            String background = elem.getAttribute("background");
            if(background.length() > 0)
            {
               processImgElement(elem, "background");
            }
         }
      }

      logInfo("End processing <img> tags for dynamic references to image resources");
   }
   
   /**
    * Process a single element that has an attribute that specifies image 
    * location path.
    * @param imgElem DOM element that has an attribute that can hold an image 
    * path which needs to be made dynamic. Assumed not <code>null</code>.
    * @param attrName Name of the attribute that holds the path, assumed not 
    * <code>null</code>.
    */
   private void processImgElement(Element imgElem, String attrName)
   {
      String psxsrc = imgElem.getAttribute("psx-" + attrName);
      if (!isEmpty(psxsrc))
         return;
      String src = imgElem.getAttribute(attrName);
      int loc = src.lastIndexOf('/');
      if (loc != -1)
         src = src.substring(loc + 1);
      src = "$rxs_img/" + src;
      imgElem.setAttribute("psx-" + attrName, src);
   }

   /**
    * Modify the HTML &lt;head&gt; element in the tidied document to achieve 
    * the following: 
    * <ol>
    *    <li>Modify the &gt;title&gt;element to make the title dynamic</li>
    *    <li>Add an XSL block to insert a global_head template</li>
    *    <li>Modify all &lt;link&gt; tags that point to CSS  files to point 
    *        to dynamic location via context variable</li>
    *    <li>Modify all &lt;script&gt; tags that point to JavaScript files 
    *        to point to dynamic location via context variable</li> 
    * </ol>
    * 
    */
   private void modifyHeader()
   {
      logInfo("Modfying HTML header...");

      //Assumes a <header> element exists
      NodeList nlTemp = m_tidiedHtmlDoc.getElementsByTagName("head");
      Element headerElem = (Element) nlTemp.item(0);

      nlTemp = headerElem.getElementsByTagName("title");
      Element title = null;
      //Remove title element(s).

      logInfo("Checking to see if a dynamic <title> tag exists");
      
      boolean dynamicTitleExists = false;
      for (int i = nlTemp.getLength() - 1; i >= 0; i--)
      {
         title = (Element) nlTemp.item(i);
         PSXmlTreeWalker walker = new PSXmlTreeWalker(title);
         String tmp = walker.getElementData().trim();
         if(tmp.startsWith("psx-"))
         {
            dynamicTitleExists = true;
            continue;
         }
         headerElem.removeChild(title);
      }
      if(dynamicTitleExists)
      {
         logInfo("Dynamic <title> tag exists and is not altered");
      }
      else
      {
         logInfo("Dynamic <title> tag does not exist. Creating new one");
         title = m_tidiedHtmlDoc.createElement("title");
         Text value = m_tidiedHtmlDoc.createTextNode("psx-shared/displaytitle");
         title.appendChild(value);
         headerElem.insertBefore(title, headerElem.getFirstChild());
      }

      logInfo("Adding template call to rxglobal_head");

      Node commentBeginXSL = m_tidiedHtmlDoc.createComment(" begin XSL ");
      Element xslCallTemplateElem =
         m_tidiedHtmlDoc.createElement("xsl:call-template");
      xslCallTemplateElem.setAttribute("name", "rxglobal_head");
      Node commentEndXSL = m_tidiedHtmlDoc.createComment(" end XSL ");
      headerElem.appendChild(commentBeginXSL);
      headerElem.appendChild(xslCallTemplateElem);
      headerElem.appendChild(commentEndXSL);

      //Process all <link> elements for CSS links
      logInfo("Processing <link> elements for dynamic CSS references ");

      nlTemp = headerElem.getElementsByTagName("link");
      for (int i = 0; i < nlTemp.getLength(); i++)
      {
         Element linkElem = (Element) nlTemp.item(i);

         String psxhref = linkElem.getAttribute("psx-href");
         if (!"".equals(psxhref))
            continue;

         String href = linkElem.getAttribute("href");
         if ("".equals(href))
            continue;

         int loc = href.lastIndexOf('/');
         if (loc != -1)
            href = href.substring(loc + 1);
         href = "$rxs_css/" + href;
         linkElem.setAttribute("psx-href", href);
      }

      //Process all <script> elements with links to javascript files
      logInfo("Processing <script> elements for dynamic references to JS resources");

      nlTemp = headerElem.getElementsByTagName("script");
      for (int i = 0; i < nlTemp.getLength(); i++)
      {
         Element scriptElem = (Element) nlTemp.item(i);
         String psxsrc = scriptElem.getAttribute("psx-src");
         if (!isEmpty(psxsrc))
            continue;

         String src = scriptElem.getAttribute("src");
         if (isEmpty(""))
            continue;

         int loc = src.lastIndexOf('/');
         if (loc != -1)
            src = src.substring(loc + 1);
         src = "$rxs_js/" + src;
         scriptElem.setAttribute("psx-src", src);
      }
      logInfo("End modfying HTML header...");
   }

   /**
    * Access method for the name of the template. The name is built by stripping
    * the file extension from the source file.
    * @return name of the global template as explained above. Never
    *         <code>null</code> or empty.
    */
   public String getName()
   {
      return m_name;
   }

   /**
    * Save the files associated with this template. First, saves the tidied and
    * pre-processed HTML document to the application directory specified during
    * construction. The file name will be constructed as template name appended
    * with "_prepared.html". Then saves the global template XSL document. The
    * name of this file is constructed by appending ".xsl" to the template name.
    * 
    * @throws IOException if save fails for any reason
    */
   public void save() throws IOException
   {
      saveTidiedHtmlSrc();
      saveXsl();
   }

   /**
    * Saves the tidied HTML document.
    * @throws IOException if save fails for any reason.
    */
   private void saveTidiedHtmlSrc() throws IOException
   {
      String fileName = m_appDir + File.separator + getName() + ".tidy";
      logInfo("Saving tidied and prepared HTML document to " + fileName);
      saveDoc(m_tidiedHtmlDoc, fileName, false);
   }

   /**
    * Saves the outer template XSL document. The path of the file is constructed
    * by concatinating:
    * {@link PSRxGlobals#ABS_GLOBAL_TEMPLATES_PATH global template path},
    * {@link #getName() template name} and ".xsl".
    * @throws IOException if save fails for any reason.
    */
   private void saveXsl() throws IOException
   {
      String fileName =
         PSRxGlobals.ABS_GLOBAL_TEMPLATES_PATH
            + File.separator
            + getName()
            + ".xsl";
      logInfo("Saving the global template XSL to " + fileName);
      saveDoc(m_xslDoc, fileName, true);
   }

   /**
    * Saves the specifed XML document to specified file path. Always uses {@
    * link PSCharSets#getInternalEncoding() encoding} while saving. Optionally 
    * adds the standard HTML entity refernces. 
    * @param doc XML document to save to the file, must not be <code>null</code>.
    * @param filePath path and name of the file to save the document to. It 
    * does not create any non existing directories in the path. Must not be 
    * <code>null</code> or empty.
    * @param addHtmlEntRef <code>true</code> to add the standard HTML entity 
    * references to the file being saved, <code>false</code> otherwise.
    * @throws IOException in case of any error writng to file.
    */
   private void saveDoc(Document doc, String filePath, boolean addHtmlEntRef)
      throws IOException
   {
      // Write out the document element using PSNodePrinter. This removes
      // the Xml and Doctype declaration.
      StringWriter swriter = new StringWriter();
      PSNodePrinter np = new PSNodePrinter(swriter);
      np.printNode(doc.getDocumentElement());
      String content = swriter.toString();

      if (addHtmlEntRef)
      {
         content =
            "<!DOCTYPE "
               + doc.getDocumentElement().getNodeName()
               + " ["
               + getDefaultEntities(null)
               + "]>"
               + NEWLINE
               + NEWLINE
               + content;
      }


      try(OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(filePath), StandardCharsets.UTF_8
               )) {

          writer.write(content);
          writer.flush();
      }
   }

   /**
    * Constant for the suffix that is appended to the name of the global
    * template file and used as the template name
    */
   public static final String GLOBAL_TEMPLATE_NAME_SUFFIX = "_root";
   
   /**
    * Name of the template. Built in the constructor by stripping the 
    * extension from the source HTML file. Never <code>null</code> or empty.
    */
   private String m_name = null;

   /**
    * Tidied HTML document. Constructed during tidying process in the 
    * constructor. Never <code>null</code> after that.
    */
   private Document m_tidiedHtmlDoc = null;

   /**
    * XSL outer templaet which is the final result desired from this object. 
    * Built by running XSpLit on the tidied source in the constructor, never 
    * <code>null</code> after that.
    */
   private Document m_xslDoc = null;

   /**
    * Folder location of the template source file. Iniialized in the 
    * constructor, never <code>null</code> after that.
    */
   private String m_appDir = null;

   /**
    * Name of the attribute of an HTML element to indicate that all the child 
    * content is to be replaced or tagged as dynamic body or local template.
    */
   private static final String ATTR_PSXBODY = "psx-localtemplate";

   /**
    * Name of the attribute of an HTML element to indicate that all the child 
    * content is to be replaced or tagged as dynamic body or local template.
    */
   private static final String ATTR_PSXSLOTNAME = "psx-slotname";

   /**
    * Name of the attribute of an HTML element attribute to indicate that the 
    * slot is editable or not.
    */
   private static final String ATTR_PSXEDITSLOT = "psxeditslot";

    /**
     * Get the default entities for the provided server root. An entry like
     * <!ENTITY % HTMLlat1 SYSTEM "<serverRoot>/DTD/HTMLlat1x.ent">%HTMLlat1;
     * will be created for all entities.
     * Include all of the entities defined for HTML, the originals are
     * available at:
     * "http://www.w3.org/TR/xhtml1/DTD/HTMLlat1x.ent"
     * "http://www.w3.org/TR/xhtml1/DTD/HTMLsymbolx.ent"
     * "http://www.w3.org/TR/xhtml1/DTD/HTMLspecialx.ent"
     * @param serverRoot
     * @return
     */
    public static String getDefaultEntities(String serverRoot)
    {
        String root = serverRoot;
        if (root == null || root.equals(""))
            root = ms_defaultServerRoot;

        return "\t<!ENTITY % HTMLlat1 SYSTEM \"/" + root + "/DTD/HTMLlat1x.ent\">" + NEWLINE + "\t\t%HTMLlat1;" + NEWLINE +
                "\t<!ENTITY % HTMLsymbol SYSTEM \"/" + root + "/DTD/HTMLsymbolx.ent\">" + NEWLINE + "\t\t%HTMLsymbol;" + NEWLINE +
                "\t<!ENTITY % HTMLspecial SYSTEM \"/" + root + "/DTD/HTMLspecialx.ent\">" + NEWLINE + "\t\t%HTMLspecial;";
    }


    /** The default server root */
    public static final String ms_defaultServerRoot = "Rhythmyx";

    /** New line string */
    public static final String NEWLINE = "\r\n";


}
