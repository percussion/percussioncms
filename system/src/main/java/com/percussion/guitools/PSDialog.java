/*
 *     Percussion CMS
 *     Copyright (C) 1999-2022 Percussion Software, Inc.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Affero General Public License for more details.
 *
 *     Mailing Address:
 *
 *      Percussion Software, Inc.
 *      PO Box 767
 *      Burlington, MA 01803, USA
 *      +01-781-438-9900
 *      support@percussion.com
 *      https://www.percussion.com
 *
 *     You should have received a copy of the GNU Affero General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>
 */

package com.percussion.guitools;

import com.percussion.UTComponents.UTFixedLabel;
import com.percussion.validation.ValidationConstraint;
import com.percussion.validation.ValidationFramework;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.EtchedBorder;
import javax.swing.table.TableCellEditor;
import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.ResourceBundle;



/**
 * The Base class for all future e2 dialogs.  PSDialog has a ValidationFramework
 * for validating programmer specified components.  This is to make sure that
 * users do not enter incorrect values for that component.
 *
 * @see ValidationFramework
 */
public class PSDialog extends JDialog
{

   // mimic all constructors of JDialog
   /**
    * The basic dialog is modal, non-resizable. If the properties file has an
    * key called "title", its value is read in and the title of the dialog is
    * set to this value.
    */
   public PSDialog()
   {
        super();
      init( true );
   }

   public PSDialog(String title)
   {
      super();

      setTitle(title);

      init( false );
   }

   public PSDialog(Dialog d)
   {
      super(d, true);
      init( true );
   }

   public PSDialog(Dialog d, String title)
   {
      super(d, title, true);
      init( false );
   }

   public PSDialog(Frame f)
   {
      super(f, true);
      init( true );
   }

   public PSDialog(Frame f, String title)
   {
      super(f, title, true);
      init( false );
   }

//
// PUBLIC METHODS
//

   /** Returns a reference to the current ValidationFramework.
    *
    */
   public ValidationFramework getValidationFramework()
   { return m_componentTest; }

   /**
    * Reinitializes the ValidationFramework within the PSDialog.
    *
    * @param
    *           c an array of Component
    *           v an array of ValidationConstraint
    */
   public void setValidationFramework(Component[] c, ValidationConstraint[] v)
   {
      m_componentTest.setFramework(this, c, v);
   }

   /** Starts the validation process.  Framework MUST be instantiated prior to this
    * call.  Typically used in a ActionListener method in response to an action
    * generated by a button.
    *
    * @return a boolean that either permits the method to stop or go further.
    */
   public boolean activateValidation()
   {
      return m_componentTest.checkValidity();
   }

   /**
    * Centers the dialog on the screen, based on its current size.
    */
   public void center()
   {
      Rectangle bounds = getScreenBoundsAt(this.getLocation());
      Dimension size = getSize();
      if(bounds != null) {
          setLocation(bounds.x + ((bounds.width - size.width) / 2),
                  bounds.y + ((bounds.height - size.height) / 2));
      }
   }

   public static Rectangle getScreenBoundsAt(Point pos) {
      GraphicsDevice gd = getGraphicsDeviceAt(pos);
      Rectangle bounds = null;
      if (gd != null) {
          bounds = gd.getDefaultConfiguration().getBounds();
   }
      return bounds;
  }

   public static GraphicsDevice getGraphicsDeviceAt(Point pos) {

      GraphicsDevice device = null;
      GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
      GraphicsDevice lstGDs[] = ge.getScreenDevices();

      ArrayList<GraphicsDevice> lstDevices = new ArrayList<GraphicsDevice>(lstGDs.length);
      for (GraphicsDevice gd : lstGDs) {
          Rectangle screenBounds = getDeviceBounds(gd);
          if (screenBounds.contains(pos)) {
              lstDevices.add(gd);
          }
      }
      if (lstDevices.size() == 1) {
          device = lstDevices.get(0);
      }

      return device;

  }
   
  public static Rectangle getDeviceBounds(GraphicsDevice device) {

      GraphicsConfiguration gc = device.getDefaultConfiguration();
      Rectangle bounds = gc.getBounds();
      return bounds;
  }
   /**
    * Creates the standard command panel with 'OK', 'Cancel' and 'Help' buttons.
    * Assigns the default actions to the buttons. Sets the 'OK' button as
    * default to the dialog.
    *
    * @param axis the layout axis of the panel, must be one of the <code>
    * SwingConstants.VERTICAL</code> or <code>SwingConstants.HORIZONTAL</code>
    * constants.
    * @param showHelp if <code>true</code> adds the 'Help' button to the panel,
    * otherwise not.
    *
    * @return the panel, never <code>null</code>
    *
    * @throws IllegalArgumentException if the <code>axis</code> is not valid.
    */
   protected JPanel createCommandPanel(int axis, boolean showHelp)
   {
      if(axis != SwingConstants.VERTICAL && axis != SwingConstants.HORIZONTAL)
         throw new IllegalArgumentException("axis is not valid.");

      UTStandardCommandPanel commandPanel =
         new UTStandardCommandPanel(this, axis, showHelp);

      getRootPane().setDefaultButton(commandPanel.getOkButton());

      return commandPanel;
   }
   
   /**
    * If the supplied table is currently being edited this stops the edit
    * mode to make sure that the changes of the currently edited cell are
    * accepted.
    * 
    * @param table the table to stop the edit mode for, may be 
    *    <code>null</code> in which case this does nothing.
    */
   public void stopTableEditor(JTable table)
   {
      if (table != null && table.isEditing())
      {
         TableCellEditor editor = table.getCellEditor();
         editor.stopCellEditing();
      }
   }

   /** The action performed by the Ok button. This is to be overridden by
    * subclasses that implements the actual functionality. Dialog closing action
    * must be handled here as well (ie: dispose(); ).
    */
   public void onOk()
   {
      m_bOk = true;
      setVisible(false);
      dispose();
   }

   /** The action performed by the Apply button. This is to be overridden by
    * subclasses that implements the actual functionality.
    */
   public void onApply()
   {
   }

   /**
    * Finds out whether OK is pressed in the dialog. Should be called after
    * dialog is disposed.
    *
    * @return <code>true</code> if the dialog is disposed by clicking 'OK',
    * otherwise <code>false</code>.
    */
   public boolean isOk()
   {
      return m_bOk;
   }

   /**
    * The action performed by the Cancel/Close button.  This is to be overridden
    * by subclasses that implements the actual functionality. Dialog closing
    * action must be handled here as well for anything more than calling
    * dispose().
    * <P>
    * <B>NOTE</B>: The method name <BIG>DOES NOT</BIG> mean it is only for the
    * &quot;Cancel&quot; button.  It can be called and used to handle
    * &quot;Close&quot; actions as well.  It is up to the discretion of the
    * programmer. Simply keep the idea, that this is for cancel/closing operation,
    * consistent.
    */
   public void onCancel()
   {
      setVisible(false);
      dispose();
   }

   /**
    * The action performed by the Help button. If the child dialog does not
    * have help, override <CODE>onHelp</CODE> and do nothing. Launches JavaHelp
    * viewer to display the help.
    */
   public void onHelp()
   {      
      if(!m_useHelpViewer)
         return;
      String fullname = getClass().getName();
      if(displayHelpUsingEclipseHelp(subclassHelpId(fullname)))
         return;
      // We are not in an the eclipse framework so use old help
      String helpId = fullname.substring( fullname.lastIndexOf(".") + 1);
      System.out.println("  " + helpId );
      //PSJavaHelp.launchHelp( subclassHelpId( helpId ), false, this);
      
   }
   
   /**
    * We use reflection to attempt to load the eclipse workbench's 
    * help manager class to see if it exists. If so we use the
    * displayHelpFromLegacy method to show help via Eclipse's help
    * system. If we fail we return false so that the help call can
    * be handled by regular JavaHelp. We use reflection so that there
    * is no dependency on the Eclipse codebase at compile time so we can
    * run this code in an applet which can't use SWT.
    * 
    * @param key the help key string, may be <code>null</code>.
    * @return <code>true</code> if help was shown via Eclipse's help
    * system, else <code>false</code>.
    */
   private boolean displayHelpUsingEclipseHelp(final String key)
   {
      String classname = "com.percussion.workbench.ui.help.PSHelpManager";
      String methodname = "displayHelpFromLegacy";
      try
      {
         Class clazz = Class.forName(classname);
         Method method = 
            clazz.getMethod(methodname, new Class[]{String.class});
         method.invoke(null, new Object[]{key});
         return true;
      }
      catch (Throwable t)
      {
         // Throwable, not Exception to catch possible ClassNotFoundError too
         return false;         
      }     
   }

//
// PROTECTED METHODS
//

   /**
    * By default, the base class name is used as the help id. However, if a dialog
    * needs to support more than 1 help page, then it should modify the id.
    * Typically, an integer will be appended to differentiate among the multiple
    * help pages associated with a single dialog.
    *
    * @param helpId The key to use in the help id mapping resource. This must
    * always be a valid, non-empty string.
    *
    * @return The passed in Id, unmodified.
   **/
   protected String subclassHelpId( String helpId )
   {
      return helpId;
   }

   /**
    * Utility method for all PSDialog subclasses to retrieve its ResourceBundle.
    *
    * @return ResourceBundle, may be <code>null</code>.
    */
   protected ResourceBundle getResources()
   {
      try {
         if ( null == m_res )
            m_res = ResourceBundle.getBundle( getResourceName(),
                       Locale.getDefault() );
      }
      catch(MissingResourceException mre)
      {
         mre.printStackTrace();
      }
      return m_res;
   }

   /**
    * Gets the resource string identified by the specified key.  If the
    * resource cannot be found, the key itself is returned.
    *
    * @param key identifies the resource to be fetched; may not be <code>null
    * </code> or empty.
    *
    * @return String value of the resource identified by <code>key</code>, or
    * <code>key</code> itself.
    *
    * @throws IllegalArgumentException if key is <code>null</code> or empty.
    */
   protected String getResourceString(String key)
   {
      if(key == null || key.trim().length() == 0)
         throw new IllegalArgumentException("key may not be null or empty");

      String resourceValue = key;
      try
      {
         if (getResources() != null)
            resourceValue = m_res.getString( key );
      } catch (MissingResourceException e)
      {
         // not fatal; warn and continue
         System.err.println( this.getClass() );
         System.err.println( e );
      }
      return resourceValue;
   }

   /**
    * Gets resource file name for this class.
    *
    * @return resource file name, never <code>null</code> or empty.
    **/
   protected String getResourceName()
   {
      return getClass().getName() + "Resources";
   }

   /**
    * Overridden method to display the dialog only if it is properly
    * initialized. Also adds the default listeners as component initialization
    * is guaranteed to be complete.
    **/
   @Override
   public void setVisible(boolean visible)
   {
      if(visible && m_bInitialized)
      {
         
         addDefaultKeyListeners(this);
         super.setVisible(visible);
      }
      else
      {
         /* The following code is added to avoid the help viewer getting closed
          * when this dialog is closed if it is visible before this dialog is
          * activated the help.
          */
//         if(m_useHelpViewer)
//         {
//            try
//            {
//               PSJavaHelp helpViewer = PSJavaHelp.getInstance();
//               if (helpViewer.isHelpDisplayed())
//               {
//                  helpViewer.setParent(null, true);
//               }
//            }
//            catch (Exception ignore)
//            {
//            }
//         }
         super.setVisible(false);
      }
   }
   
   /**
    * Overriden to add the default listeners
    */
   @Override
   public void pack()
   {
       addDefaultKeyListeners(this);
       super.pack();       
   }

   /**
    * Creates a compound border used on panels that group controls. The outer
    * border is a titled border. The inner border is an empty border. The
    * empty border is added because insufficient space is left between
    * components and the line of the titled border. This is a utility method
    * for derived classes, it is not used by this class.
    *
    * @param title The title for the border. <code>null</code> is the same as
    * the empty string.
    */
   public static Border createGroupBorder( String title )
   {
      if ( null == title )
         title = "";
      Border tb = BorderFactory.createTitledBorder(
         new EtchedBorder( EtchedBorder.LOWERED ), title );
      // leave more space between the titled border and the components
      Border eb = BorderFactory.createEmptyBorder( 0, 5, 5, 5 );
      return BorderFactory.createCompoundBorder( tb, eb );
   }


   /**
    * Creates a box set up with a label that is right justified, with glue
    * on the left side. The supplied component is used as the component that
    * this label is being used for.
    *
    * @param text The text for the label.
    *
    * @param labelFor The control that this label describes.
    */
   public static Box createLabel( String text, JComponent labelFor )
   {
      UTFixedLabel label = new UTFixedLabel( text, SwingConstants.RIGHT );
      if ( null != labelFor )
         label.setLabelFor( labelFor );
      Box panel = Box.createHorizontalBox();
      panel.add( Box.createHorizontalGlue());
      panel.add( label );
      return panel;
   }

  /**
   * Recursively adds the default key listener to the component
   * passed in and all child components. The default listener listens for
   * the escape and f1 keys which should have the same behaviour in all dialogs
   * i.e. escape calls <code>onCancel()</code> and f1 call onHelp()</code>.
   *
   * This method is called by {@link #setVisible(boolean)} or {@link #pack()}
   * and can also be explicitly called by a subclass.
   *
   * @param comp component to add the listeners to. Cannot be <code>null</code>.
   */
  protected void addDefaultKeyListeners(Component comp)
  {
      if(null == comp)
         throw new IllegalArgumentException("Component cannot be null.");
      if(comp instanceof Container &&
         ((Container)comp).getComponentCount() > 0)
      {
          Component[] children = ((Container)comp).getComponents();
          for(int i = 0; i < children.length; i++)
             addDefaultKeyListeners(children[i]);
      }
      
      comp.addKeyListener(m_defaultKeyListener);
  }
  
 
  
 
//
// PRIVATE METHODS
//

   /**
    * Initializes the dialog, setting default values.
    *
    * @param bSetTitle if <code>true</code>, tries to load the title from the
    * resource bundle using the key "title". If found, it then sets the title
    * to this value.
    */
   private void init( boolean bSetTitle )
   {
      setModal(true);
      setResizable(false);
      setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      addWindowListener(new WindowAdapter()
      {
         @Override
         public void windowClosing(@SuppressWarnings("unused") WindowEvent e)
         {
            onCancel();
         }
      });

      m_componentTest = new ValidationFramework();

      // Create the default key listener which will
      // listen for the escape key and f1 key in all
      // components of this dialog.
      m_defaultKeyListener = new KeyAdapter()
      {
         @Override
         public void keyReleased(KeyEvent e)
         {
            if (KeyEvent.VK_ESCAPE == e.getKeyCode())
               onCancel();
            if (KeyEvent.VK_F1 == e.getKeyCode())
               onHelp();

         }
      };

      try
      {
         if ( bSetTitle )
         {
            if(getResources() != null)
                setTitle(getResources().getString("title"));
         }
      }
      catch ( MissingResourceException e )
      {
         // don't do anything, the derived class didn't add a title key
      }
   }


   /**
    * Flag to indicate this dialog initialization. Initialized to
    * <code>true</code> and set to <code>false</code> when error happens in
    * derived class initialization.
    **/
   protected boolean m_bInitialized = true;

   /**
    * Key listener that listens for escape and f1 key
    * presses. If escape is caught then onCancel is called
    * if f1 is caught then onHelp is called. Initialized in
    * {@link #init(boolean)}
    */
   private KeyAdapter m_defaultKeyListener;
   private ValidationFramework m_componentTest;
   private ResourceBundle m_res;

   /**
    * The flag to indicate whether the dialog is disposed by clicking 'OK' or
    * not. Initialized to <code>false</code> and set to <code>true</code> before
    * disposing the dialog in <code>onOk()</code>
    */
   protected boolean m_bOk;
   
   /**
    * Use help viewer. This is exposed as some newer subclasses do not want to 
    * use the old help viewer. Defaults to <code>true</code>.
    */
   protected boolean m_useHelpViewer = true;
}
